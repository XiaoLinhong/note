# 主要思想

一门把编程习惯 用语法表达出来的编程语言。

### 什么变量？ 

   是一段内存的标识，也就是这段内存的别名；

   **定义变量**就是申请内存（申请内存也可以通过系统调用来完成）。

   **内存**存储了所有数据（包括执行的代码，代码区不讨论），大致可以分为三个区域（简化的说）：
     a. 全局/静态存储区: static float values[1000];
     b. 栈： 函数中的普通局部数据
     c. 堆： 动态分配的数据

   定义变量，可以理解为在栈结构上，保存了（开辟了一片内存）一段已知大小的数据 或者 描述一段堆内存的信息（指针）。
      堆上可以定义变量吗？ 堆上只可以存储数据，这段数据的描述存在栈上，这个描述有个名字，叫变量（一般都是指针类型，智能指针）。
      <!-- float *values = (float *)malloc(1000 * sizeof(float));  -->

   怎么去描述一段连续内存? 内存地址 + 长度； 这种结构的大小是已知的（指针的大小已知）。

   栈的结构是动态的，随着函数的调用和返回动态增大或者减小。

   随着函数的返回，该函数的栈桢消失（只是改变了栈顶寄存器），返回之后，函数内部定义的变量也就没办法引用，该函数栈桢中的数据理论上应该是无效的。

   语义非常清晰，但是在C语言（类似）的编程中，会出现一些编程错误（应该程序员彻底理解语义之后，自己避免）:
      1) 函数有可能返回了指向该函数栈桢中数据的指针？ 悬垂指针
      2) 函数申请的堆上的数据结构（该函数栈桢中数据保存的是描述一段连续内存的内存）是否释放了？ 什么时候应该释放（不释放，内存会爆炸、内存泄漏）？ 
      3) 函数有没有权限去修改外部调用函数栈桢中的数据： 多线程中的数据竞争问题；

   不同语言对变量（内存）的访问、 修改、 销毁处理思路很不一样。

// 对于堆上的数据，谁去销毁
  a. C/C++: malloc/free（程序员自己去做）；
  b. python/java/js：垃圾回收机制（运行时）；
  c. rust: 基于所有权模型、生命周期的自动堆内存释放（编译阶段）；  
      所有权明确了谁去销毁；
      生命周期明确了销毁前，不会有其他引用，避免悬垂指针。
      单一可变引用，明确了数据不出现竞争情况。

// 避免悬垂指针；
   rust: 生命周期: 结构体中的生命周期，确实很烦人，但是也是有必要的；
   大部分语言不考虑这个问题，程序员自己解决；

## 强大的抽象能力
   rust: 模板展开（泛型编程 + trait绑定；）

## 并发编程
  rust: 异步解决方案： Future async/awaite;

## 函数式编程
  
  &String: 包含容量信息（可变的数据结构）；
  &str: 不包含容量信息； 切片的一种；

  ##: 在良好实现的分层机制中，对于某一层的实现者而言，下一层的绝大部分是不需关心的。
  随着我们创造越来越多、越来越高层的抽象，编程实现会变得更加简单，但成为专业程序员也越来越难。

  事实上，如果要从整个技术界中选一个本科教育一般不大重视、但又极度有价值的术语，我会选闭包和高阶函数？

  返回函数，那么函数确实是一个动态数据接口，应该存储在堆上？
  
  闭包本身是一个数据结构

  struct Closure {
    captured_variables: ..., // 存储捕获的环境变量
    // 逻辑代码的调用是编译器插入的，Closure 实现了 Fn、FnMut 或 FnOnce
  }

  fn(Args) -> Output
